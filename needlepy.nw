% -*- mode: Noweb; noweb-code-mode: python-mode -*-

% This is a Noweb file describing and providing the implementation of NeedlePy,
% a needlet library.
%
% You can either extract a LaTeX document describing the code or the code
% itself from this file by using "noweave" or "notangle". It is better however
% to use the Makefile provided with this distribution, as it uses the
% appropriate command line switches for each command.
%
% Author: Maurizio Tomasi, 2010

\documentclass[a4paper,10pt,twoside]{article}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{noweb}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{ccaption}
\usepackage{textcomp}
\usepackage{titlesec}
\usepackage{mathpazo}
\usepackage[round]{natbib}

\hyphenation{Needle-Py}

% Command used to indicate a section
\newcommand{\sectmark}{\S\ }

\titleformat{\section}[block]
  {\centering\normalfont\bfseries}
  {\sectmark\thesection.}{.5em}{}
\titleformat{\subsection}[runin]
  {\normalfont\bfseries}
  {\thesubsection.}{.5em}{}[. ]
\titleformat{\subsubsection}[runin]
  {\normalfont\bfseries}
  {}{.2em}{}[. ]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{fancy}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\sectionmark}[1]{%
  \markright{\thesection.\ #1}}
\fancyhf{}
\fancyhead[L,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}

\fancypagestyle{plain}{%
  \fancyhf{}
  \fancyfoot[C]{\thepage}
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0pt}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\captionnamefont{\small\bfseries}
\captiontitlefont{\small\itshape}

\hypersetup{pdftitle={NeedlePy},
pdfauthor={Maurizio Tomasi, Andrea Zonca},
pdfsubject={Commented implementation of the NeedlePy library},
pdfkeywords={CMB {data analysis} {needlets}},
pdfborder={0 0 0}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\NeedlePy}{NeedlePy}

\newcommand{\ud}{\mathrm{d}}
\newcommand{\vect}[1]{\mathbf{#1}}
\newcommand{\vers}[1]{\hat{#1}}

\begin{document}

\bibliographystyle{plainnat}

\title{\NeedlePy}
\author{M.~Tomasi, A.~Zonca}
\maketitle

\begin{abstract}
This document describes the implementation of \NeedlePy{}, a needlet library
written in Python.
\end{abstract}

\tableofcontents

\section{Introduction}

Needlets have been introduced by \citet{2006NarcowichNeedlets} as a powerful
tool for the analysis of spherical random fields. They can be seen as the
analogous of wavelets over a $\mathbb{S}^n$ field (a $n$-dimensional sphere),
as they implement a way of decomposing signals into a set of functions (called
``needlets'') which are well localized both in pixel and harmonic space. The
most important result in needlet theory is summed up by \textit{Proposition 1}
in \citet{2009BaldiNeedlets}, which says (1) that needlets implement a
\emph{tight frame} over $\mathbb{S}^n$ (i.e.\ a set of function which shares
many properties with orthonormal bases), and (2) that such frame has the
localization properties mentioned above.

\Citet{2008MarinucciNeedletsAndCMB} introduced a practical approach to employ
needlets for CMB data analysis. Such approach rotates around the definition of a
so-called \emph{window function} $b(\cdot)$, which allows to apply the needlet
transformation directly in the harmonic space. Unfortunately, the window
function $b^2(\cdot)$ is built using the non-analytic function $f(t)$, and it
involves the calculation of non-algebraic integrals, and it therefore
complicates any numerical implementation of the needlet concept.

This document discusses the implementation of a fast Python library for the
estimation of needlet transformations for Healpix maps following the articles
cited above.  First of all, let us recall the steps required to build the
window function $b(\cdot)$, while at the same time underlying any numerical
issue each step might pose:
\begin{enumerate}
\item Define
\begin{equation}
f(t) := \begin{cases}
\exp \left(\frac{1}{1 - t^2}\right), & t \in [-1, 1], \\
0, & \text{otherwise}.
\end{cases}
\end{equation}
Note that $f$ is $C^\infty$, but it is not analytic around points $t = \pm 1$,
because $f^{(n)} (\pm 1) = 0\ \forall n$. Therefore, such function cannot be
approximated by Taylor series over the interval $[-1, 1]$.

\begin{figure}[tbf]
    \centering
    \includegraphics{psi.pdf}
    \caption{\label{fig:psi} Graph of $\psi(u)$ (eq.~\ref{eq:psi}).}
\end{figure}

\item Define
\begin{equation}
\label{eq:psi}
\psi (u) := \frac{\int_{-1}^u f(t)\,\ud t}{\int_{-1}^1 f(t)\,\ud t}.
\end{equation}
The fact that $\psi \in C^\infty$ derives from the same property for $f$. The
behavior of $\psi(u)$ is shown in fig.~\ref{fig:psi}. Such function requires
the evaluation of an integral which has no algebraic form. Therefore, numerical
integration algorithms must be implemented. The denominator has the following
value (truncated to 18 digits):
\begin{equation}
K := \int_{-1}^1 f(t)\,\ud t = 0.443\,993\,816\,168\,079\,438.
\end{equation}

\begin{figure}
    \centering
    \includegraphics{phi.pdf}
    \caption{\label{fig:phi} Graph of $\varphi_B (t)$.}
\end{figure}

\item Define
\begin{equation}
\label{eq:phi}
\varphi_B (t) := \begin{cases}
1, & t \in \left[0, \frac1B\right], \\
\psi\left(1 - \frac{2B}{B-1} \left(t - \frac1B\right)\right), & t \in
\left(\frac1B, 1\right), \\ 0, & t > 1.
\end{cases}
\end{equation}
for $B > 0$. The behavior of $\varphi_B (t)$ is shown in fig.~\ref{fig:phi}.

\begin{figure}
    \centering
    \includegraphics{b.pdf}
    \caption{\label{fig:b} Graph of $b (\ell / B^j)$ for $j = 5$. The two plots
refer to two different values of $B$: it is evident that such parameter makes
$b$ ``pick'' different regions in the harmonic space.}
\end{figure}

\item Define the window function $b (\cdot)$ such that
\begin{equation}
\label{eq:b}
b^2 (\xi) := \varphi_B \left(\frac{\xi}B\right) - \varphi_B(\xi).
\end{equation}
\end{enumerate}

Once $b (\cdot) = \sqrt{\bigl(b^2 (\cdot) \bigr)}$ (i.e.\ we take the plus
sign) has been defined, the random needlets coefficients of a scalar field in
the harmonic domain $\{a_{\ell m}\}_{\ell m}$ is given by
\begin{equation}
\label{eq:needletTransformation}
\beta_{jk} = \sqrt{\lambda_{jk}} \sum_\ell b\left(\frac\ell{B^j}\right)
\sum_{m=-\ell}^\ell a_{\ell m} Y_{\ell m} (\xi_{jk}),
\end{equation}
where $\{\xi_{jk}\}$ is a set of \emph{cubature points}, and it is usually
taken to be the center of each pixel in an Healpix map. When working with
Healpix maps, the $j$ index conventionally refers to a given \texttt{NSIDE}
parameter, while $k$ is the pixel number, running from 0 to $12 \times
\mathtt{NSIDE}^2 - 1$.

Eq.~\eqref{eq:needletTransformation} is the convolution of a spherical field
$T$ (represented by the set of $a_{\ell m}$) with the window function. This
means that in pixel space the equation can be written as
\begin{equation}
\beta_{jk} = \int_{\mathbf{S}^2} T (\vers{\gamma}) \psi_{jk}
(\vers{\gamma})\,\ud\Omega,
\end{equation}
where $\psi_{jk}$ are the needlet:
\begin{equation}
\psi_{jk} (\vers{\gamma}) = \sqrt{\lambda_{jk}} \sum_\ell
b\left(\frac\ell{B^j}\right) \sum_{m = -\ell}^\ell Y_{lm}^* (\vers{\gamma})
Y_{lm} (\xi_{jk}).
\end{equation}


\section{Numerical implementation of the base functions}

\subsection{Estimating $\psi$}

A good place to start implementing \NeedlePy{} is to look for a cubic spline
interpolation of $\psi(u)$ in eq.~\eqref{eq:psi}.  This kind of approximation
allows (1) to avoid estimating the integral in eq.~\eqref{eq:psi} for each
value of $u$ we are interested, and (2) to compute third-order polynomials
instead of functions involving exponentials. We shall use the fact that
\begin{equation}
\label{eq:psiParity}
\psi (u) = 1 - \psi (-u) \quad \text{for $u > 0$}
\end{equation}
to limit the domain where to look for the interpolation.

We use Wolfram Mathematica's \texttt{NIntegrate} to calculate the value of
$\psi(u)$ over an uniform set of points in $[-1 - \varepsilon, 0 +
\varepsilon]$, where $\varepsilon = 0.01$ is the spacing between consecutive
points\footnote{Slightly exceeding the $[-1, 0]$ range allows to model the
behavior of $\psi(u)$ near the points $u = -1$ and $u = 0$ more accurately.},
and use such points in [[scipy.interpolate.splrep]]. The following code defines
the spline:
<<Private definitions>>=
_PSI_SPLINE = scipy.interpolate.splrep ( \
    np.arange (-1.01, 0.02, 0.01),
    np.array([  0.00000000e+00,   0.00000000e+00,   6.10726446e-26,
	        1.80473593e-14,   1.63146885e-10,   1.81011396e-08,
	        3.33941762e-07,   2.47115014e-06,   1.07501585e-05,
	        3.33635137e-05,   8.23638779e-05,   1.72785830e-04,
	        3.21411357e-04,   5.45573939e-04,   8.62196482e-04,
	        1.28711301e-03,   1.83464846e-03,   2.51740299e-03,
	        3.34618479e-03,   4.33004296e-03,   5.47636332e-03,
	        6.79099953e-03,   8.27842094e-03,   9.94186438e-03,
	        1.17834820e-02,   1.38044808e-02,   1.60052501e-02,
	        1.83854783e-02,   2.09442559e-02,   2.36801676e-02,
	        2.65913725e-02,   2.96756753e-02,   3.29305873e-02,
	        3.63533793e-02,   3.99411282e-02,   4.36907558e-02,
	        4.75990635e-02,   5.16627608e-02,   5.58784904e-02,
	        6.02428494e-02,   6.47524071e-02,   6.94037205e-02,
	        7.41933466e-02,   7.91178536e-02,   8.41738297e-02,
	        8.93578906e-02,   9.46666853e-02,   1.00096901e-01,
	        1.05645269e-01,   1.11308565e-01,   1.17083611e-01,
	        1.22967283e-01,   1.28956505e-01,   1.35048255e-01,
	        1.41239561e-01,   1.47527507e-01,   1.53909226e-01,
	        1.60381906e-01,   1.66942786e-01,   1.73589155e-01,
	        1.80318352e-01,   1.87127766e-01,   1.94014833e-01,
	        2.00977036e-01,   2.08011904e-01,   2.15117011e-01,
	        2.22289973e-01,   2.29528448e-01,   2.36830134e-01,
	        2.44192769e-01,   2.51614129e-01,   2.59092025e-01,
	        2.66624305e-01,   2.74208849e-01,   2.81843571e-01,
	        2.89526414e-01,   2.97255354e-01,   3.05028392e-01,
	        3.12843559e-01,   3.20698910e-01,   3.28592527e-01,
	        3.36522513e-01,   3.44486996e-01,   3.52484123e-01,
	        3.60512062e-01,   3.68568999e-01,   3.76653139e-01,
	        3.84762704e-01,   3.92895928e-01,   4.01051064e-01,
	        4.09226374e-01,   4.17420136e-01,   4.25630637e-01,
	        4.33856174e-01,   4.42095054e-01,   4.50345591e-01,
	        4.58606108e-01,   4.66874931e-01,   4.75150394e-01,
	        4.83430833e-01,   4.91714588e-01,   5.00000000e-01,
	        5.08285412e-01]))
@ %def _PSI_SPLINE

Then, we use this spline and eq.~\eqref{eq:psiParity} to define [[psi]] over
the whole $[-1,1]$ domain:

<<Definition of [[psi]]>>=
def psi(u):
    neg_u = np.clip (-np.abs (u), -1.0, 0.0)
    value = scipy.interpolate.splev (neg_u, _PSI_SPLINE)

    if np.isscalar (u):
	if u > 0.0:
	    return 1.0 - value
	else:
	    return value
    else:
	u = np.array (u)  # Ensure that "u" is of the proper type
	return np.where (u > 0.0, 1 - value, value)
@ %def psi

\begin{figure}[tbf]
    \centering
    \includegraphics{psi_error.pdf}
    \caption{\label{fig:psiError} Graph of $\tilde\psi(u) - \psi(u)$, i.e.\ the
error in our spline interpolation with respect to a direct numerical estimate
of the integral in eq.~\protect\ref{eq:psi}.}
\end{figure}

If we denote our spline estimator for $\psi$ as $\tilde\psi$, then
fig.~\ref{fig:psiError} shows the quantity
\[
\tilde\psi (u) - \psi(u)
\]
for $u \in [-1, 1]$. This shows our uncertainty in the reconstruction of
the ``true'' $\psi(u)$, which is of the order of $10^{-9}$, i.e.\ the same
magnitude of the truncation of the numbers used to define [[_PSI_SPLINE]].

We now define a test case which checks the correctness of the implementation of
[[phi]]:
<<Test cases>>=
class TestPsi (unittest.TestCase):
    def test_notable_points (self):
	self.assertAlmostEqual (psi (-1.0), 0.0)
	self.assertAlmostEqual (psi ( 0.0), 0.5)
	self.assertAlmostEqual (psi (+1.0), 1.0)

    def test_boundaries (self):
	self.assertAlmostEqual (psi (-1.0), psi (-1.1))
	self.assertAlmostEqual (psi (+1.0), psi (+1.1))

    def test_vectorial (self):
	u = [-1.0, 0.0, 1.0]
	self.assertTrue (np.allclose (psi (u), [0.0, 0.5, 1.0]))

    def test_sparse_points (self):
	u        = [-0.606531, -0.31831, 0.367879, 0.56419]
	expected = [0.0663502, 0.245443, 0.790487, 0.912829]
	self.assertTrue (np.allclose (psi (u), expected))
@ %def TestPsi


\subsection{Estimation of $\varphi$}

As for [[psi]], we use the [[numpy.clip]] function in the definition of [[phi]]
($\varphi$, eq.~\ref{eq:phi}) to properly take care of the regions outside
$[1/B, 1]$:
<<Definition of [[phi]]>>=
def phi (t, B):
    invB = 1.0/B
    # Ensure that "t" is of the correct type
    if not np.isscalar (t): t = np.array (t)
    val = np.clip (1 - 2*B/(B - 1) * (t - invB), -1.0, 1.0)
    return psi (val)
@ %def phi

As we did with [[psi]], we define a test case for [[phi]] as well:
<<Test cases>>=
class TestPhi (unittest.TestCase):
    def test_notable_points (self):
	self.assertAlmostEqual (phi (0.0, 2.0), 1.0)
	self.assertAlmostEqual (phi (0.5, 2.0), 1.0)
	self.assertAlmostEqual (phi (1.0, 2.0), 0.0)

	self.assertAlmostEqual (phi (0.0, 5.0), 1.0)
	self.assertAlmostEqual (phi (0.2, 5.0), 1.0)
	self.assertAlmostEqual (phi (1.0, 5.0), 0.0)

    def test_boundaries (self):
	self.assertAlmostEqual (phi (-0.1, 2.0), 1.0)
	self.assertAlmostEqual (phi (-0.1, 4.0), 1.0)

	self.assertAlmostEqual (phi (1.1, 2.0), 0.0)
	self.assertAlmostEqual (phi (1.1, 4.0), 0.0)

    def test_vectorial (self):
	u = [0.0, 0.2, 1.0]
	self.assertTrue (np.allclose (phi (u, 5.0), [1.0, 1.0, 0.0]))

    def test_sign (self): # This is crucial for the definition of "b"
	u = np.arange (0.0, 1.0, 0.05)
	self.assertTrue (np.all (phi (u, 2.0) >= 0.0))
	self.assertTrue (np.all (phi (u, 3.0) >= 0.0))
	self.assertTrue (np.all (phi (u, 4.5) >= 0.0))
@ %def TestPhi
Note that we do not check for ``sparse'' points as we did in [[TestPsi]], since
we assume that the implementation of [[psi]] (upon which [[phi]] is based) has
already passed all the tests.


\subsection{Estimation of the window function}

After having implemented [[phi]], the implementation of [[window_function]]
($b$, eq.~\ref{eq:b}) is straightforward:
<<Definition of [[window_function]]>>=
def window_function (u, B):
    return np.sqrt (np.clip (phi (u / B, B) - phi (u, B), 0.0, 5.0))
@ %def window_function


\section{The needlet transformation}

Using eq.~\eqref{eq:needletTransformation} and the HealPy function
[[healpy.alm2signal]] we are now able to estimate the needlet transformation
for a given Healpix map.


\section{The main program}

This is the incarnation of the main program. It is used to test the goodness of
the implementation by means of a number of unit tests:

<<*>>=
#!/usr/bin/env python

import numpy as np
import scipy.interpolate
import scipy.special
import unittest
import sys

<<Private definitions>>

<<Definition of [[psi]]>>
<<Definition of [[phi]]>>
<<Definition of [[window_function]]>>

<<Test cases>>

if __name__ == "__main__":
    unittest.main ()
@

\appendix

\section{Index of symbols}

Here we provide a list of the symbols used in the code. Each reference is of
the form \texttt{nL}, where \texttt{n} is the number of the page and \texttt{L}
a letter specifying the code chunk within that page starting from ``a''.
Underlined references point to the definition of the symbol.

\nowebindex

\bibliography{needlepy}
\end{document}
