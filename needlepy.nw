% -*- mode: Noweb; noweb-code-mode: python-mode -*-

% This is a Noweb file describing and providing the implementation of NeedlePy,
% a needlet library.
%
% You can either extract a LaTeX document describing the code or the code
% itself from this file by using "noweave" or "notangle". It is better however
% to use the Makefile provided with this distribution, as it uses the
% appropriate command line switches for each command.
%
% Author: Maurizio Tomasi, 2010

\documentclass[a4paper,10pt,twoside]{article}
\usepackage{a4wide}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{noweb}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{ccaption}
\usepackage{textcomp}
\usepackage{titlesec}
\usepackage{mathpazo}
\usepackage[round]{natbib}

\hyphenation{Needle-Py}

% Command used to indicate a section
\newcommand{\sectmark}{\S\ }

\titleformat{\section}[block]
  {\centering\normalfont\bfseries}
  {\sectmark\thesection.}{.5em}{}
\titleformat{\subsection}[runin]
  {\normalfont\bfseries}
  {\thesubsection.}{.5em}{}[. ]
\titleformat{\subsubsection}[runin]
  {\normalfont\bfseries}
  {}{.2em}{}[. ]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{fancy}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\sectionmark}[1]{%
  \markright{\thesection.\ #1}}
\fancyhf{}
\fancyhead[L,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}

\fancypagestyle{plain}{%
  \fancyhf{}
  \fancyfoot[C]{\thepage}
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0pt}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\captionnamefont{\small\bfseries}
\captiontitlefont{\small\itshape}

\hypersetup{pdftitle={NeedlePy},
pdfauthor={Maurizio Tomasi, Andrea Zonca},
pdfsubject={Commented implementation of the NeedlePy library},
pdfkeywords={CMB {data analysis} {needlets}},
pdfborder={0 0 0}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\NeedlePy}{NeedlePy}

\newcommand{\ud}{\mathrm{d}}
\newcommand{\vect}[1]{\mathbf{#1}}
\newcommand{\vers}[1]{\hat{#1}}

\begin{document}

\bibliographystyle{plainnat}

\title{\NeedlePy}
\author{M.~Tomasi, A.~Zonca}
\maketitle

\begin{abstract}
This document describes the implementation of \NeedlePy{}, a needlet library
written in Python.
\end{abstract}

\tableofcontents

\section{Introduction}

Needlets have been introduced by \citet{2006NarcowichNeedlets} as a powerful
tool for the analysis of spherical random fields. They can be seen as the
analogous of wavelets over a $\mathbb{S}^n$ field (a $n$-dimensional sphere),
as they implement a way of decomposing signals into a set of functions (called
``needlets'')Â which are well localized both in pixel and harmonic space. The
most important result in needlet theory is summed up by \textit{Proposition 1}
in \citet{2009BaldiNeedlets}, which says (1) that needlets implement a
\emph{tight frame} over $\mathbb{S}^n$ (i.e.\ a set of function which shares
many properties with orthonormal bases), and (2) that such frame has the
localization properties mentioned above.

\Citet{2008MarinucciNeedletsAndCMB} introduced a practical approach to employ
needlets for CMB data analysis. Such approach rotates around the definition of a
so-called \emph{window function} $b(\cdot)$, which allows to apply the needlet
transformation directly in the harmonic space. Unfortunately, the window
function $b(\cdot)$ is built using the non-analytic function $f(t)$, and it
involves the calculation of non-algebraic integrals, and it therefore
complicates any numerical implementation of the needlet concept.

This document discusses the implementation of a fast Python library for the
estimation of needlet transformations for Healpix maps following the articles
cited above.  First of all, let us recall the steps required to build the
window function $b(\cdot)$, while at the same time underlying any numerical
issue each step might pose:
\begin{enumerate}
\item Define
\begin{equation}
f(t) := \begin{cases}
\exp \left(\frac{1}{1 - t^2}\right), & t \in [-1, 1], \\
0, & \text{otherwise}.
\end{cases}
\end{equation}
Note that $f$ is $C^\infty$, but it is not analytic around points $t = \pm 1$,
because $f^{(n)} (\pm 1) = 0\ \forall n$. Therefore, such function cannot be
approximated easily using Taylor series\footnote{The usage of
Pad\'e\ approximants reduces the problem while however not completely curing it
(tests were made up to the approximant $[15/13]_f (t)$ built around points $t =
0$ and $t = \pm \frac12$).} over the interval $[-1, 1]$.

\item Define
\begin{equation}
\label{eq:psi}
\psi (u) := \frac{\int_{-1}^u f(t)\,\ud t}{\int_{-1}^1 f(t)\,\ud t}.
\end{equation}
The fact that $\psi \in C^\infty$ derives from the same property for $f$. Such
function requires the evaluation of an integral which has no algebraic form.
Therefore, numerical integration algorithms must be implemented. The
denominator has the following value (truncated to 18 digits):
\begin{equation}
K := \int_{-1}^1 f(t)\,\ud t = 0.443\,993\,816\,168\,079\,438.
\end{equation}

\item Define
\begin{equation}
\label{eq:phi}
\varphi_B (t) := \begin{cases}
1, & t \in \left[0, \frac1B\right], \\
\psi\left(1 - \frac{2B}{B-1} \left(t - \frac1B\right)\right), & t \in
\left(\frac1B, 1\right), \\ 0, & t > 1.
\end{cases}
\end{equation}
for $B > 0$.

\item Define the window function $b (\cdot)$ such that
\begin{equation}
\label{eq:b}
b^2 (\xi) := \varphi_B \left(\frac{\xi}B\right) - \varphi_B(\xi).
\end{equation}
\end{enumerate}

Once $b (\cdot) = \sqrt{\bigl(b^2 (\cdot) \bigr)}$ (i.e.\ we take the plus
sign) has been defined, the random needlets coefficients of a scalar field in
the harmonic domain $\{a_{\ell m}\}_{\ell m}$ are given by
\begin{equation}
\label{eq:needletTransformation}
\beta_{jk} = \sqrt{\lambda_{jk}} \sum_\ell b\left(\frac\ell{B^j}\right)
\sum_{m=-\ell}^\ell a_{\ell m} Y_{\ell m} (\xi_{jk}),
\end{equation}
where $\{\xi_{jk}\}$ is a set of \emph{cubature points}, and it is usually
taken to be the center of each pixel in an Healpix map. When working with
Healpix maps, the $j$ index conventionally refers to a given \texttt{NSIDE}
parameter, while $k$ is the pixel number, running from 0 to $12 \times
\mathtt{NSIDE}^2 - 1$. The $\lambda_{jk}$ parameter is the normalization
coefficient of the needlet and is usually taken to be equal to the number of
pixels for the $k$-th component.

Eq.~\eqref{eq:needletTransformation} is the convolution of a spherical field
$T$ (represented by the set of $a_{\ell m}$) with the window function. This
means that in pixel space the equation can be written as
\begin{equation}
\beta_{jk} = \int_{\mathbf{S}^2} T (\vers{\gamma}) \psi_{jk}
(\vers{\gamma})\,\ud\Omega,
\end{equation}
where $\psi_{jk}$ is the needlet:
\begin{equation}
\label{eq:needletInPixelSpace}
\psi_{jk} (\vers{\gamma}) = \sqrt{\lambda_{jk}} \sum_\ell
b\left(\frac\ell{B^j}\right) \sum_{m = -\ell}^\ell Y_{lm}^* (\vers{\gamma})
Y_{lm} (\xi_{jk}).
\end{equation}

In the following sections we are going to define Python functions for each of
these functions.


\section{Numerical implementation of the base functions}

\subsection{Estimating $\psi$}

A good place to start implementing \NeedlePy{} is to look for a cubic spline
interpolation of $\psi(u)$ in eq.~\eqref{eq:psi}.  This kind of approximation
allows (1) to avoid estimating the integral in eq.~\eqref{eq:psi} for each
value of $u$ we are interested, and (2) to compute third-order polynomials
instead of functions involving exponentials. We shall use the fact that
\begin{equation}
\label{eq:psiParity}
\psi (u) = 1 - \psi (-u) \quad \text{for $u > 0$}
\end{equation}
to limit the domain where to look for the interpolation to $[-1, 0]$.

We use Wolfram Mathematica's \texttt{NIntegrate} to calculate the value of
$\psi(u)$ over an uniform set of points in $[-1 - \varepsilon, 0 +
\varepsilon]$, where $\varepsilon = 0.01$ is the spacing between consecutive
points\footnote{Slightly exceeding the $[-1, 0]$ range allows to model the
behavior of $\psi(u)$ near the points $u = -1$ and $u = 0$ more accurately.},
and use such points in [[scipy.interpolate.splrep]]. The following code defines
the spline:
<<Private definitions>>=
_PSI_SPLINE = scipy.interpolate.splrep ( \
    np.arange (-1.01, 0.02, 0.01),
    np.array([  0.00000000e+00,   0.00000000e+00,   6.10726446e-26,
	        1.80473593e-14,   1.63146885e-10,   1.81011396e-08,
	        3.33941762e-07,   2.47115014e-06,   1.07501585e-05,
	        3.33635137e-05,   8.23638779e-05,   1.72785830e-04,
	        3.21411357e-04,   5.45573939e-04,   8.62196482e-04,
	        1.28711301e-03,   1.83464846e-03,   2.51740299e-03,
	        3.34618479e-03,   4.33004296e-03,   5.47636332e-03,
	        6.79099953e-03,   8.27842094e-03,   9.94186438e-03,
	        1.17834820e-02,   1.38044808e-02,   1.60052501e-02,
	        1.83854783e-02,   2.09442559e-02,   2.36801676e-02,
	        2.65913725e-02,   2.96756753e-02,   3.29305873e-02,
	        3.63533793e-02,   3.99411282e-02,   4.36907558e-02,
	        4.75990635e-02,   5.16627608e-02,   5.58784904e-02,
	        6.02428494e-02,   6.47524071e-02,   6.94037205e-02,
	        7.41933466e-02,   7.91178536e-02,   8.41738297e-02,
	        8.93578906e-02,   9.46666853e-02,   1.00096901e-01,
	        1.05645269e-01,   1.11308565e-01,   1.17083611e-01,
	        1.22967283e-01,   1.28956505e-01,   1.35048255e-01,
	        1.41239561e-01,   1.47527507e-01,   1.53909226e-01,
	        1.60381906e-01,   1.66942786e-01,   1.73589155e-01,
	        1.80318352e-01,   1.87127766e-01,   1.94014833e-01,
	        2.00977036e-01,   2.08011904e-01,   2.15117011e-01,
	        2.22289973e-01,   2.29528448e-01,   2.36830134e-01,
	        2.44192769e-01,   2.51614129e-01,   2.59092025e-01,
	        2.66624305e-01,   2.74208849e-01,   2.81843571e-01,
	        2.89526414e-01,   2.97255354e-01,   3.05028392e-01,
	        3.12843559e-01,   3.20698910e-01,   3.28592527e-01,
	        3.36522513e-01,   3.44486996e-01,   3.52484123e-01,
	        3.60512062e-01,   3.68568999e-01,   3.76653139e-01,
	        3.84762704e-01,   3.92895928e-01,   4.01051064e-01,
	        4.09226374e-01,   4.17420136e-01,   4.25630637e-01,
	        4.33856174e-01,   4.42095054e-01,   4.50345591e-01,
	        4.58606108e-01,   4.66874931e-01,   4.75150394e-01,
	        4.83430833e-01,   4.91714588e-01,   5.00000000e-01,
	        5.08285412e-01]))
@ %def _PSI_SPLINE

Then, we use this spline and eq.~\eqref{eq:psiParity} to define [[psi]]\ over
the whole $[-1,1]$ domain:

<<Function definitions>>=
def psi(u):
    neg_u = np.clip (-np.abs (u), -1.0, 0.0)
    value = scipy.interpolate.splev (neg_u, _PSI_SPLINE)

    if np.isscalar (u):
	if u > 0.0:
	    return 1.0 - value
	else:
	    return value
    else:
	u = np.array (u)  # Ensure that "u" is of the proper type
	return np.where (u > 0.0, 1 - value, value)
@ %def psi

\begin{figure}[tbf]
    \centering
    \includegraphics{psi_error.pdf}
    \caption{\label{fig:psiError} Graph of $\tilde\psi(u) - \psi(u)$, i.e.\ the
error in our spline interpolation with respect to a direct numerical estimate
of the integral in eq.~\protect\ref{eq:psi}.}
\end{figure}

If we denote our spline estimator for $\psi$ as $\tilde\psi$, then
fig.~\ref{fig:psiError} shows the quantity
\[
\tilde\psi (u) - \psi(u)
\]
for $u \in [-1, 1]$. This shows our uncertainty in the reconstruction of
the ``true'' $\psi(u)$, which is of the order of $10^{-9}$, i.e.\ the same
magnitude of the truncation of the numbers used to define [[_PSI_SPLINE]].

We now define a test case which checks the correctness of the implementation of
[[phi]]:
<<Test cases>>=
class TestPsi (unittest.TestCase):
    def test_notable_points (self):
	self.assertAlmostEqual (psi (-1.0), 0.0)
	self.assertAlmostEqual (psi ( 0.0), 0.5)
	self.assertAlmostEqual (psi (+1.0), 1.0)

    def test_boundaries (self):
	self.assertAlmostEqual (psi (-1.0), psi (-1.1))
	self.assertAlmostEqual (psi (+1.0), psi (+1.1))

    def test_vectorial (self):
	u = [-1.0, 0.0, 1.0]
	self.assertTrue (np.allclose (psi (u), [0.0, 0.5, 1.0]))

    def test_sparse_points (self):
	u        = [-0.606531, -0.31831, 0.367879, 0.56419]
	expected = [0.0663502, 0.245443, 0.790487, 0.912829]
	self.assertTrue (np.allclose (psi (u), expected))
@ %def TestPsi

\begin{figure}[tbf]
    \centering
    \includegraphics{psi.pdf}
    \caption{\label{fig:psi} Graph of $\psi(u)$ (eq.~\ref{eq:psi}) as
calculated by \texttt{psi}.}
\end{figure}

To have a visual check of our implementation of [[psi]], we define a small
program which writes the points of the curve into a file. Such file has been
used to produce fig.~\ref{fig:psi}.
<<test-psi.py>>=
#!/usr/bin/env python

import numpy as np
import needlepy

EPSILON = 0.01
for x in np.arange (-1.0, 1.0 + EPSILON, EPSILON):
    print "%.2f %.6f" % (x, needlepy.psi (x))
@

\subsection{Estimation of $\varphi$}

As for [[psi]], we use the [[numpy.clip]]\ function in the definition of
[[phi]]\ ($\varphi$, eq.~\ref{eq:phi}) to properly take care of the regions
outside
$[1/B, 1]$:
<<Function definitions>>=
def phi (t, B):
    invB = 1.0/B
    # Ensure that "t" is of the correct type
    if not np.isscalar (t): t = np.array (t)
    val = np.clip (1 - 2*B/(B - 1) * (t - invB), -1.0, 1.0)
    return psi (val)
@ %def phi

As we did with [[psi]], we define a test case for [[phi]]\ as well:
<<Test cases>>=
class TestPhi (unittest.TestCase):
    def test_notable_points (self):
	self.assertAlmostEqual (phi (0.0, 2.0), 1.0)
	self.assertAlmostEqual (phi (0.5, 2.0), 1.0)
	self.assertAlmostEqual (phi (1.0, 2.0), 0.0)

	self.assertAlmostEqual (phi (0.0, 5.0), 1.0)
	self.assertAlmostEqual (phi (0.2, 5.0), 1.0)
	self.assertAlmostEqual (phi (1.0, 5.0), 0.0)

    def test_boundaries (self):
	self.assertAlmostEqual (phi (-0.1, 2.0), 1.0)
	self.assertAlmostEqual (phi (-0.1, 4.0), 1.0)

	self.assertAlmostEqual (phi (1.1, 2.0), 0.0)
	self.assertAlmostEqual (phi (1.1, 4.0), 0.0)

    def test_vectorial (self):
	u = [0.0, 0.2, 1.0]
	self.assertTrue (np.allclose (phi (u, 5.0), [1.0, 1.0, 0.0]))

    def test_sign (self): # This is crucial for the definition of "b"
	u = np.arange (0.0, 1.0, 0.05)
	self.assertTrue (np.all (phi (u, 2.0) >= 0.0))
	self.assertTrue (np.all (phi (u, 3.0) >= 0.0))
	self.assertTrue (np.all (phi (u, 4.5) >= 0.0))
@ %def TestPhi
Note that we do not check for ``sparse'' points as we did in [[TestPsi]], since
we assume that the implementation of [[psi]]\ (upon which [[phi]]\ is based)
has already passed all the tests.

We provide a program which tabulates the values of $\varphi_B (t)$ for a range
of values for $t$:
<<test-phi.py>>=
#!/usr/bin/env python

import numpy as np
import needlepy

B = 3.0
EPSILON = 0.05
for u in np.arange (0.0, 1.0 + EPSILON, EPSILON):
    print "%.3f %.5f" % (u, needlepy.phi (u, B))
@

\begin{figure}
    \centering
    \includegraphics{phi.pdf}
    \caption{\label{fig:phi} Graph of $\varphi_B (t)$.}
\end{figure}


\subsection{Estimation of the window function}

After having implemented [[phi]], the implementation of [[window_function]]
($b$, eq.~\ref{eq:b}) is straightforward:
<<Function definitions>>=
def window_function (u, B):
    return np.sqrt (np.clip (phi (u / B, B) - phi (u, B), 0.0, 5.0))
@ %def window_function

\begin{figure}
    \centering
    \includegraphics{b.pdf}
    \caption{\label{fig:b} Graph of $b (\ell / B^j)$ for $j = 5$. The two plots
refer to two different values of $B$: it is evident that such parameter makes
$b$ ``pick'' different regions in the harmonic space.}
\end{figure}

As usual, we provide a small program that tabulates the values of this
function:
<<test-b.py>>=
#!/usr/bin/env python

import numpy as np
import needlepy

j = 5
EPSILON = 0.05
for l in xrange (500):
    val = lambda x, B : x / (B**j)
    print "%d %.5f %.5f" % (l,
			    needlepy.window_function (val (l, 2.72), 2.72),
			    needlepy.window_function (val (l, 2.50), 2.50))
@
Fig.~\ref{fig:b} shows the two needlets (with $B = 2.72$ and $B = 2.50$)
calculated by this program.


\section{The needlet transformation}

\subsection{Needlets in pixel space}

We are now going to provide a fast implementation of
eq.~\eqref{eq:needletInPixelSpace} in the following function:
<<Function definitions>>=
def needlet (pos, B, j, center = (0.0, 0.0)):
    '''Return the value of a needlet at position=(theta, phi) relative to the
    center of the needlet.'''

    <<Initialize variables for the calculation of the needlet>>
    <<Cycle over $\ell$ and calculate the Legendre polynomials>>
    <<Compute the needlet and return the result>>
@ %def needlet

Eq.~\eqref{eq:needletInPixelSpace} typically involves a summation over a wide
range of $\ell$ and $m$, but we can reduce the number of addends by employing
the fact that for any given $\ell$ the following identity holds:
\begin{equation}
\label{eq:LegendreAndSphHarmonics}
P_l (\cos\gamma) = \frac{4\pi}{2\ell + 1} 
\sum_{m = -\ell}^{\ell} Y_{\ell m} (\theta_1, \varphi_1) Y_{\ell m}^*
(\theta_2, \varphi_2),
\end{equation}
where $P_l$ is the $l$-th Legendre polynomial, and
\[
\cos\gamma = \cos\theta_1 \cos\theta_2
+ \sin\theta_1 \sin\theta_2 \cos(\varphi_1 - \varphi_2).
\]
We initialize the [[cos_gamma]]\ constant according to this formula:
<<Initialize variables for the calculation of the needlet>>=
cos_gamma = np.cos (center[0]) * np.cos (pos[0]) \
	    + (np.sin (center[0]) * np.sin (pos[0]) \
	       * np.cos (center[1] - pos[1]))
@

Since the window function $b$ has support in $[1/B, B]$, it follows that
$b(\ell/B^j)$ has support in $[B^{j-1}, B^{j+1}]$. This allows us to reduce the
number of $\ell$ over which the summation must be carried: in symbols,
\[
\sum_\ell \rightarrow \sum_{\ell = \lfloor B^{j-1} \rfloor}^{\lceil B^{j+1} \rceil},
\]
where $\lfloor\cdot\rfloor$ and $\lceil\cdot\rceil$ indicate floor and ceil
rounding operations respectively:
<<Initialize variables for the calculation of the needlet>>=
start_l = int (np.floor (B**(j-1)))
end_l   = int (np.ceil (B**(j+1)))
@

Next, using the recurrence relation\footnote{The reader might ask why we have
not used [[scipy.special.legendre]] instead of implementing our own code for
calculating $P_\ell (x)$. We discovered that such function leads to wrong
results for big values of $\ell$ ($\ell \gtrsim 100$) --- the function does not
return the value of the polynomial at one specific point, but instead the
coefficients of the polinomial, whose magnitude grows quite fast and therefore
produce NaNs for high values of $\ell$. We have therefore decided to use here
the same recurrence relation implemented by the GNU Scientific Library (GSL) in
[[gsl_sf_legendre_Pl]], which works for $\ell \leq 100\,000$.}
\begin{equation}
(\ell + 1) P_l (x) = (2\ell + 1) x P_{\ell - 1} (x) - \ell P_{\ell - 2} (x),
\end{equation}
we create the array [[pl_values]]\ which will contain the set $\{P_\ell
(\cos\gamma)\}$ for $\ell = 0\ldots \mathtt{end_l}$:
<<Cycle over $\ell$ and calculate the Legendre polynomials>>=
pl_values = np.zeros (end_l + 1)
pl_values[0] = 1.0
if end_l > 1: pl_values[1] = cos_gamma
for cur_l in xrange (2, end_l + 1):
    pl_values[cur_l] = ((cos_gamma * (2 * cur_l - 1) * pl_values[cur_l - 1] \
			   - (cur_l - 1) * pl_values[cur_l - 2])) / cur_l
@

Since eq.~\eqref{eq:LegendreAndSphHarmonics} involves a $(2\ell + 1)/4\pi$
factor, we must rescale [[pl_values]]\ accordingly:
<<Cycle over $\ell$ and calculate the Legendre polynomials>>=
l_range = np.arange (0, end_l + 1, dtype = 'float')
pl_values = pl_values * (l_range * 2.0 + 1) / (4.0 * np.pi)
@

Finally, we can compute the result of the function:
<<Compute the needlet and return the result>>=
pl_values = pl_values[start_l:end_l+1]
l_range   = l_range  [start_l:end_l+1]
return np.sum (window_function (l_range / (B**j), B) * pl_values)
@

\begin{figure}
    \centering
    \includegraphics{needlet.pdf}
    \caption{\label{fig:needletPixelSpace} Graph of needlet $\varphi_{jk}$ ($B
= 2.0$, $j = 7$) in pixel space as a function of the $\theta$ angle from the
cubic point $\xi_{jk}$. Note the good localization in space: this property
motivates the name ``needlet'' for these mathematical objects.}
\end{figure}

The following function computes the profile of a needlet with $B = 2.0$ and $j = 7$:
<<test-needlet.py>>=
#!/usr/bin/env python

import numpy as np
import needlepy

B = 2.0
j = 7

EPSILON = 0.0025
normalization = needlepy.needlet ((0.0, 0.0), B, j)
for theta in np.arange (-np.pi / 8.0, np.pi / 8.0 + EPSILON, EPSILON):
    print theta, \
	needlepy.needlet ((theta, 0.0), B, j) / normalization
@ The result is shown in fig.~\ref{fig:needletPixelSpace}.

\subsection{Transformation for a random spherical field}

Using eq.~\eqref{eq:needletTransformation} and function [[healpy.alm2signal]]\
we are now able to estimate the needlet transformation
for a given Healpix map [TODO].


\section{The main program}

This is the incarnation of the main program. It is used to test the goodness of
the implementation by means of a number of unit tests:

<<needlepy.py>>=
#!/usr/bin/env python

import numpy as np
import scipy.interpolate
import scipy.special
import unittest
import sys

<<Private definitions>>
<<Function definitions>>
<<Test cases>>

if __name__ == "__main__":
    unittest.main ()
@

\appendix

\section{Index of symbols}

Here we provide a list of the symbols used in the code. Each reference is of
the form \texttt{nL}, where \texttt{n} is the number of the page and \texttt{L}
a letter specifying the code chunk within that page starting from ``a''.
Underlined references point to the definition of the symbol.

\nowebindex

\bibliography{needlepy}
\end{document}
