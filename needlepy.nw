% -*- mode: Noweb; noweb-code-mode: python-mode -*-

% This is a Noweb file describing and providing the implementation of NeedlePy,
% a needlet library.
%
% You can either extract a LaTeX document describing the code or the code
% itself from this file by using "noweave" or "notangle". It is better however
% to use the Makefile provided with this distribution, as it uses the
% appropriate command line switches for each command.
%
% Author: Maurizio Tomasi, 2010

\documentclass[a4paper,10pt,twoside]{article}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{noweb}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{ccaption}
\usepackage{textcomp}
\usepackage{titlesec}
\usepackage{mathpazo}
\usepackage[round]{natbib}

\hyphenation{Needle-Py}

% Command used to indicate a section
\newcommand{\sectmark}{\S\ }

\titleformat{\section}[block]
  {\centering\normalfont\bfseries}
  {\sectmark\thesection.}{.5em}{}
\titleformat{\subsection}[runin]
  {\normalfont\bfseries}
  {\thesubsection.}{.5em}{}[. ]
\titleformat{\subsubsection}[runin]
  {\normalfont\bfseries}
  {}{.2em}{}[. ]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{fancy}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\sectionmark}[1]{%
  \markright{\thesection.\ #1}}
\fancyhf{}
\fancyhead[L,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}

\fancypagestyle{plain}{%
  \fancyhf{}
  \fancyfoot[C]{\thepage}
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0pt}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\captionnamefont{\small\bfseries}
\captiontitlefont{\small\itshape}

\hypersetup{pdftitle={NeedlePy},
pdfauthor={Maurizio Tomasi, Andrea Zonca},
pdfsubject={Commented implementation of the NeedlePy library},
pdfkeywords={CMB {data analysis} {needlets}},
pdfborder={0 0 0}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\NeedlePy}{NeedlePy}

\newcommand{\ud}{\mathrm{d}}
\newcommand{\vect}[1]{\mathbf{#1}}
\newcommand{\vers}[1]{\mathbf{\hat{#1}}}

\begin{document}

\bibliographystyle{plainnat}

\title{\NeedlePy}
\author{M.~Tomasi, A.~Zonca}
\maketitle

\begin{abstract}
This document describes the implementation of \NeedlePy{}, a needlet library
written in Python.
\end{abstract}

\tableofcontents

\section{Introduction}

\section{Implementation of the window function}

\Citet{2007MarinucciNeedletsAndCMB} introduce a practical approach to use
needlets for CMB data analysis. Unfortunately, the window function $b^2(\cdot)$
is built using the non-analytic function $f(t)$, and it involves the
calculation of non-algebraic integrals. To allow for a fast implementation, we
are therefore looking for polynomial approximations of $b$.

Let us recall the steps required to build the window function $b^2(\cdot)$,
while at the same time underlying any numerical issue each step might pose:
\begin{enumerate}
\item Define
\begin{equation}
f(t) := \begin{cases}
\exp \left(\frac{1}{1 - t^2}\right), & t \in [-1, 1], \\
0, & \text{otherwise}.
\end{cases}
\end{equation}
Such function is $C^\infty$, but it is not analytic around points $t = \pm 1$,
because $f^{(n)} (\pm 1) = 0 \forall n$. Therefore, such function cannot be
approximated by Taylor series over the interval $[-1, 1]$.

\begin{figure}[tbf]
    \centering
    \includegraphics{psi.pdf}
    \caption{\label{fig:psi} Graph of $\psi(u)$ (eq.~\ref{eq:psi}).}
\end{figure}

\item Define
\begin{equation}
\label{eq:psi}
\psi (u) := \frac{\int_{-1}^u f(t)\,\ud t}{\int_{-1}^1 f(t)\,\ud t}.
\end{equation}
The behavior of $\psi(u)$ is shown in fig.~\ref{fig:psi}. Such function
requires the evaluation of an integral which has no algebraic form. Therefore,
numerical integration algorithms must be implemented. The denominator has the
following value (truncated to 18 digits):
\begin{equation}
K := \int_{-1}^1 f(t)\,\ud t = 0.443\,993\,816\,168\,079\,438.
\end{equation}

\item Define
\begin{equation}
\varphi_B (t) := \begin{cases}
1, & t \in \left[0, \frac1B\right], \\
\psi\left(1 - \frac{2B}{B-1} \left(t - \frac1B\right)\right), & t \in \left(\frac1B, 1\right), \\
0, & t > 1.
\end{cases}
\end{equation}
for $B > 0$.

\item Define the window function $b^2 (\cdot)$:
\begin{equation}
b^2 (\xi) = \varphi_B \left(\frac{\xi}B\right) - \varphi_B(\xi).
\end{equation}
\end{enumerate}

A good place to start implementing \NeedlePy{} is to look for a cubic spline
interpolation of $\psi(u)$ in eq.~\eqref{eq:psi}.  This kind of approximation
allows (1) to avoid estimating the integral in eq.~\eqref{eq:psi} for each
value of $u$ we are interested, and (2) to compute third-order polynomials
instead of functions involving exponentials. We shall use the fact that
\begin{equation}
\label{eq:psiParity}
\psi (u) = 1 - \psi (-u) \quad \text{for $u > 0$}
\end{equation}
to limit the domain where to look for the interpolation.

We use Wolfram Mathematica's \texttt{NIntegrate} to calculate the value of
$\psi(u)$ over an uniform set of points in $[-1 - \varepsilon, 0 +
\varepsilon]$, where $\varepsilon = 0.05$ is the spacing between consecutive
points\footnote{Slightly exceeding the $[-1, 0]$ range allows to model the
behavior of $\psi(u)$ near the points $u = -1$ and $u = 0$ more accurately.},
and use such points in [[scipy.interpolate.splrep]]. The following code defines
the spline:
<<Private definitions>>=
_PSI_SPLINE = scipy.interpolate.splrep ( \
    np.arange (-1.01, 0.02, 0.01),
    np.array([  0.00000000e+00,   0.00000000e+00,   6.10726446e-26,
	        1.80473593e-14,   1.63146885e-10,   1.81011396e-08,
	        3.33941762e-07,   2.47115014e-06,   1.07501585e-05,
	        3.33635137e-05,   8.23638779e-05,   1.72785830e-04,
	        3.21411357e-04,   5.45573939e-04,   8.62196482e-04,
	        1.28711301e-03,   1.83464846e-03,   2.51740299e-03,
	        3.34618479e-03,   4.33004296e-03,   5.47636332e-03,
	        6.79099953e-03,   8.27842094e-03,   9.94186438e-03,
	        1.17834820e-02,   1.38044808e-02,   1.60052501e-02,
	        1.83854783e-02,   2.09442559e-02,   2.36801676e-02,
	        2.65913725e-02,   2.96756753e-02,   3.29305873e-02,
	        3.63533793e-02,   3.99411282e-02,   4.36907558e-02,
	        4.75990635e-02,   5.16627608e-02,   5.58784904e-02,
	        6.02428494e-02,   6.47524071e-02,   6.94037205e-02,
	        7.41933466e-02,   7.91178536e-02,   8.41738297e-02,
	        8.93578906e-02,   9.46666853e-02,   1.00096901e-01,
	        1.05645269e-01,   1.11308565e-01,   1.17083611e-01,
	        1.22967283e-01,   1.28956505e-01,   1.35048255e-01,
	        1.41239561e-01,   1.47527507e-01,   1.53909226e-01,
	        1.60381906e-01,   1.66942786e-01,   1.73589155e-01,
	        1.80318352e-01,   1.87127766e-01,   1.94014833e-01,
	        2.00977036e-01,   2.08011904e-01,   2.15117011e-01,
	        2.22289973e-01,   2.29528448e-01,   2.36830134e-01,
	        2.44192769e-01,   2.51614129e-01,   2.59092025e-01,
	        2.66624305e-01,   2.74208849e-01,   2.81843571e-01,
	        2.89526414e-01,   2.97255354e-01,   3.05028392e-01,
	        3.12843559e-01,   3.20698910e-01,   3.28592527e-01,
	        3.36522513e-01,   3.44486996e-01,   3.52484123e-01,
	        3.60512062e-01,   3.68568999e-01,   3.76653139e-01,
	        3.84762704e-01,   3.92895928e-01,   4.01051064e-01,
	        4.09226374e-01,   4.17420136e-01,   4.25630637e-01,
	        4.33856174e-01,   4.42095054e-01,   4.50345591e-01,
	        4.58606108e-01,   4.66874931e-01,   4.75150394e-01,
	        4.83430833e-01,   4.91714588e-01,   5.00000000e-01,
	        5.08285412e-01]))
@ %def _PSI_SPLINE

Then, we use this spline and eq.~\eqref{eq:psiParity} to define [[psi]] over
the whole $[-1,1]$ domain:

<<Definition of [[psi]]>>=
def psi(u):
    neg_u = -np.abs (u)
    value = scipy.interpolate.splev (neg_u, _PSI_SPLINE)

    if np.isscalar (u):
	if u > 0.0:
	    return 1.0 - value
	else:
	    return value
    else:
	u = np.array (u)  # Ensure that "u" is of the proper type
	result = np.where (u > 0.0, 1 - value, value)

	return result
@ %def psi

\begin{figure}[tbf]
    \centering
    \includegraphics{psi_error.pdf}
    \caption{\label{fig:psiError} Graph of $\tilde\psi (u) - \psi(u)$, i.e.\
the error in our implementation of [[phi]] with respect to the integral
definition of eq.~\ref{eq:psi}.}
\end{figure}

If we denote our spline estimator for $\psi$ as $\tilde\psi$, then
fig.~\ref{fig:psiError} shows the quantity
\[
\tilde\psi (u) - \psi(u)
\]
for $u \in [-1, 1]$. This shows our uncertainty in the reconstruction of
the ``true'' $\psi(u)$, which is of the order of $10^{-9}$, i.e.\ the same
magnitude of the truncation of the numbers used to define [[_PSI_SPLINE]].

We now define a test case which checks the correctness of the implementation of
[[phi]]:
<<Test cases>>=
class TestPhi (unittest.TestCase):
    def test_notable_points (self):
	self.assertAlmostEqual (psi (-1.0), 0.0)
	self.assertAlmostEqual (psi ( 0.0), 0.5)
	self.assertAlmostEqual (psi (+1.0), 1.0)

    def test_vectorial (self):
	u = [-1.0, 0.0, 1.0]
	self.assertTrue (np.allclose (psi (u), [0.0, 0.5, 1.0]))

    def test_sparse_points (self):
	u        = [-0.606531, -0.31831, 0.367879, 0.56419]
	expected = [0.0663502, 0.245443, 0.790487, 0.912829]
	self.assertTrue (np.allclose (psi (u), expected))
@ %def TestPhi

\section{The main program}

This is the incarnation of the main program. It is used to test the goodness of
the implementation by means of a number of unit tests:

<<*>>=
#!/usr/bin/env python

import numpy as np
import scipy.interpolate
import unittest
import sys

<<Private definitions>>

<<Definition of [[psi]]>>

<<Test cases>>

if __name__ == "__main__":
    unittest.main ()
@

\appendix

\section{Index of symbols}

Here we provide a list of the symbols used in the code. Each reference is of
the form \texttt{nL}, where \texttt{n} is the number of the page and \texttt{L}
a letter specifying the code chunk within that page starting from ``a''.
Underlined references point to the definition of the symbol.

\nowebindex

\bibliography{needlepy}
\end{document}
